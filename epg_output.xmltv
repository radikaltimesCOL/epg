import pandas as pd
import xml.etree.ElementTree as ET
from xml.dom import minidom
from datetime import datetime, timedelta
import pytz # Library for timezone handling
import re # For regex extraction

# --- Configuration ---
CSV_FILE_PATH = 'Soccer.xlsx - Sheet1.csv'
XMLTV_OUTPUT_FILE = 'soccer_epg.xml'
DEFAULT_GAME_DURATION_MINUTES = 120
TIMEZONE = 'America/New_York' # IANA timezone identifier for ET
NUM_CHANNELS = 80
CHANNEL_PREFIX = 'Soccer'
# Use the year the script is run or a specific year if needed
# Since the data is '5/4', let's assume the current year.
# Note: The context states the current date is May 4, 2025. We'll use 2025.
YEAR = 2025

# --- Helper Function to Format Datetime for XMLTV ---
def format_xmltv_datetime(dt_obj):
    """Formats a timezone-aware datetime object for XMLTV standard."""
    if dt_obj.tzinfo is None:
        # This should not happen if localization is done correctly
        print(f"Warning: datetime object {dt_obj} lacks timezone info.")
        # Fallback: Assume UTC or raise error? For now, format as is.
        return dt_obj.strftime('%Y%m%d%H%M%S +0000')

    # Format: YYYYMMDDHHMMSS <space>+/-HHMM
    # Get UTC offset in hours and minutes
    offset_seconds = dt_obj.utcoffset().total_seconds()
    offset_hours = int(offset_seconds // 3600)
    offset_minutes = int((offset_seconds % 3600) // 60)
    offset_sign = '+' if offset_seconds >= 0 else '-'
    # Create the offset string (e.g., "-0400" for EDT)
    offset_str = f"{offset_sign}{abs(offset_hours):02d}{abs(offset_minutes):02d}"

    return dt_obj.strftime(f'%Y%m%d%H%M%S {offset_str}')

# --- Load and Clean Data ---
print(f"Reading CSV file: {CSV_FILE_PATH}")
try:
    df_original = pd.read_csv(CSV_FILE_PATH)
except FileNotFoundError:
    print(f"Error: Input CSV file not found at {CSV_FILE_PATH}")
    exit()

df_cleaned = df_original.dropna(axis=1, how='all').copy()

# Regex pattern from successful attempt (Attempt 2)
# Captures: League, Home Team, Away Team (handling multi-word), Month, Day, Time(HH:MM), Timezone(ET)
pattern_refined = r'\|([^|]+)\|\s*([^vs]+?)\s+vs\s+([^-\s]+(?:\s+[^-\s]+)*?)\s*-\s*(\d{1,2})/(\d{1,2})\s*-\s*(\d{1,2}:\d{2})(ET)'

print("Parsing titles...")
extracted_data = df_cleaned['Title'].str.extract(pattern_refined)

# Assign extracted data to new columns
df_cleaned[['League', 'Home Team', 'Away Team', 'Month', 'Day', 'Time', 'Timezone_Abbr']] = extracted_data

# --- Data Preprocessing & Filtering ---
# Drop rows where essential parts (like date/time/teams) couldn't be extracted
df_cleaned = df_cleaned.dropna(subset=['League', 'Home Team', 'Away Team', 'Month', 'Day', 'Time'])
df_cleaned = df_cleaned.reset_index(drop=True) # Reset index after dropping rows

# Convert types and create naive datetime objects first
try:
    df_cleaned['Month'] = pd.to_numeric(df_cleaned['Month']).astype(int)
    df_cleaned['Day'] = pd.to_numeric(df_cleaned['Day']).astype(int)
    # Combine Year, Month, Day, Time into a single string for parsing
    datetime_str = (
        str(YEAR) + '-' +
        df_cleaned['Month'].astype(str).str.zfill(2) + '-' +
        df_cleaned['Day'].astype(str).str.zfill(2) + ' ' +
        df_cleaned['Time']
    )
    # Create naive datetime objects (no timezone yet)
    df_cleaned['NaiveStartDateTime'] = pd.to_datetime(datetime_str, format='%Y-%m-%d %H:%M', errors='coerce')
except Exception as e:
    print(f"Error converting date/time components: {e}")
    # Drop rows where conversion failed
    df_cleaned = df_cleaned.dropna(subset=['NaiveStartDateTime'])

print(f"Successfully parsed {len(df_cleaned)} matches.")

if len(df_cleaned) == 0:
    print("No match data could be parsed. Exiting.")
    exit()

# --- Timezone Handling ---
print(f"Applying timezone: {TIMEZONE}")
tz = pytz.timezone(TIMEZONE)

# Localize the naive datetime to the specified timezone
df_cleaned['StartDateTime'] = df_cleaned['NaiveStartDateTime'].apply(lambda dt: tz.localize(dt))

# Calculate StopDateTime based on default duration
duration_delta = timedelta(minutes=DEFAULT_GAME_DURATION_MINUTES)
df_cleaned['StopDateTime'] = df_cleaned['StartDateTime'] + duration_delta


# --- Build XMLTV Structure ---
print("Generating XMLTV structure...")
# Create root element <tv>
tv_root = ET.Element('tv', attrib={'generator-info-name': 'Custom Soccer EPG Script'})

# Create <channel> elements
print(f"Generating {NUM_CHANNELS} channel entries...")
for i in range(1, NUM_CHANNELS + 1):
    channel_id = f"{CHANNEL_PREFIX} {i:02d}"
    channel_elem = ET.SubElement(tv_root, 'channel', attrib={'id': channel_id})
    display_name_elem = ET.SubElement(channel_elem, 'display-name')
    display_name_elem.text = channel_id

# Create <programme> elements for actual games and pre-game events
print("Generating program entries...")
match_count = 0
for index, row in df_cleaned.iterrows():
    match_count += 1
    if match_count > NUM_CHANNELS:
        print(f"Warning: More matches ({len(df_cleaned)}) than channels ({NUM_CHANNELS}). Skipping remaining matches.")
        break

    channel_id = f"{CHANNEL_PREFIX} {match_count:02d}"
    game_start_time = row['StartDateTime']
    game_stop_time = row['StopDateTime']

    # --- Generate Pre-Game Events ---
    pre_game_title = f" Game will start at {game_start_time.strftime('%H:%M%Z')}" # e.g., " Game will start at 09:00EDT"
    # Correct title format as requested: " Game will start at HH:MMET"
    # Need to determine if it's EDT or EST for the "ET" suffix reliably, or just use "ET"
    # Let's stick to the user request format using "ET" explicitly.
    pre_game_title = f" Game will start at {game_start_time.strftime('%H:%M')}ET"


    day_start_time = game_start_time.replace(hour=0, minute=0, second=0, microsecond=0)
    current_pre_game_start = day_start_time

    while current_pre_game_start < game_start_time:
        # Stop time is 2 hours later, but capped at the actual game start time
        current_pre_game_stop = min(current_pre_game_start + timedelta(hours=2), game_start_time)

        # Avoid creating zero-duration events if game starts exactly on a 2-hour mark
        if current_pre_game_start >= current_pre_game_stop:
            break

        pre_game_elem = ET.SubElement(tv_root, 'programme', attrib={
            'start': format_xmltv_datetime(current_pre_game_start),
            'stop': format_xmltv_datetime(current_pre_game_stop),
            'channel': channel_id
        })
        title_elem = ET.SubElement(pre_game_elem, 'title', attrib={'lang': 'en'})
        title_elem.text = pre_game_title
        cat_elem = ET.SubElement(pre_game_elem, 'category', attrib={'lang': 'en'})
        cat_elem.text = 'Sports' # Generic category

        # Move to the next pre-game slot
        current_pre_game_start = current_pre_game_stop


    # --- Generate Actual Game Event ---
    programme_elem = ET.SubElement(tv_root, 'programme', attrib={
        'start': format_xmltv_datetime(game_start_time),
        'stop': format_xmltv_datetime(game_stop_time),
        'channel': channel_id
    })

    # Title (e.g., "EPL: Brighton vs Newcastle")
    title_elem = ET.SubElement(programme_elem, 'title', attrib={'lang': 'en'})
    title_elem.text = f"{row['League']}: {row['Home Team']} vs {row['Away Team']}"

    # Description
    desc_elem = ET.SubElement(programme_elem, 'desc', attrib={'lang': 'en'})
    desc_elem.text = f"Live {row['League']} action: {row['Home Team']} takes on {row['Away Team']}."

    # Category
    cat_elem1 = ET.SubElement(programme_elem, 'category', attrib={'lang': 'en'})
    cat_elem1.text = 'Sports'
    cat_elem2 = ET.SubElement(programme_elem, 'category', attrib={'lang': 'en'})
    cat_elem2.text = 'Soccer'

# --- Write XML File ---
print(f"Writing XMLTV file to: {XMLTV_OUTPUT_FILE}")
# Use minidom for pretty printing (indentation)
xml_string = ET.tostring(tv_root, encoding='UTF-8', method='xml')
dom = minidom.parseString(xml_string)
pretty_xml_as_string = dom.toprettyxml(indent="  ", encoding='UTF-8')

try:
    with open(XMLTV_OUTPUT_FILE, "wb") as f: # Write in binary mode for UTF-8
        f.write(pretty_xml_as_string)
    print("Successfully generated XMLTV file.")
except Exception as e:
    print(f"Error writing XML file: {e}")
